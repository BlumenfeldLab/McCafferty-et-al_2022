# -*- coding: utf-8 -*-
"""
Final plotting of unit figures
Created on Thu Mar  4 06:33:16 2021

NB: This script is used in the creation of final figures/values for the paper.
It currently requires data generated by Phase_analysis.py (for pSWCth), and the
database generated by build_database.py (references all raw data locations).

Other than pSWCth, all data analysis (firing rate timecourses, ISI covariances,
xcorrs, and rasters) are done within this script.

@author: cpm49
"""

# Import required libraries & modules - first generic & then project-specific
from os.path import expanduser
home = expanduser('~')

import sys # Allows the definition of the python search path
sys.path.insert(0, home+'/mnt/Data4/GAERS_Codes/DataExtraction')
sys.path.insert(0, home+'/mnt/Data4/GAERS_Codes/AnalysisCodes')
sys.path.insert(0, home+'/mnt/Data4/GAERS_Codes/CellCodes')
sys.path.insert(0, home+'/mnt/Data4/GAERS_Codes/SeizureCodes')

sys.path.insert(0,'/opt/anaconda2/lib/python2.7/site-packages')

import cluster_cells as cc
import numpy as np
import scipy.stats as ss
import scipy.signal as sig
import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator
import LoadData as ld
import build_database as bd
import pandas as pd
import itertools
import pickle as pk
import seaborn as sns

data_dir = home+'/mnt/Data4/GAERS_Data/'

database = bd.load_in_dataframe(dataframe=home+'/mnt/Data4/GAERS_Data/GAERS_Objects.pkl') # get reference file

database = bd.clean_liveDB(database) # remove sessions that don't have both cells and seizures


# First load group attributions of each location

with open(home+'/mnt/Data4/CtxCellClasses.pkl','rb') as f1:
    cortical_assignments = pk.load(f1)
    
cortical_assignments = cortical_assignments.rename(columns={'Cells':'Cell'})
            
with open(home+'/mnt/Data4/ThalCellClasses.pkl','rb') as f2:
    thalamic_assignments = pk.load(f2)
    
thalamic_assignments = thalamic_assignments.rename(columns={'Cells':'Cell'})

assignments = cortical_assignments.append(thalamic_assignments)

# Set the transition period, window size in ms, bin size in ms, overlap in ms
period = 'onset'
window = 10000
bin_size = 500
bin_len = 100
overlap = 0 
fs = 1000

# Create some dataframes to hold results
SzTransFiringRates = pd.DataFrame([],columns = ['Start','End','Baseline','Cell','Type','Animal'])
SzTransISIcov = pd.DataFrame([],columns = ['Start','End','Cell','Type','Animal'])


# Get all cell information
cell_df = database.loc[(database.Type == 'Cell')]
cortcell_df = database.loc[(database.Type == 'Cell') & (database.label == 'Cortical')]
thalcell_df = database.loc[(database.Type == 'Cell') & (database.label == 'Thalamic')]


cell_sess = cell_df['recording_id'].unique() # find all unique session/recording IDs



# Figure b: firing rate timecourses at seizure start and end

for sess in cell_sess: # sess = '2018-10-13_14-25-39_1_1'
# First load the required data types: spike times and seizure times
    sess_spks = ld.sess_cell_load(sess)
    
    sess_szs = (ld.sess_seiz_load(sess)).astype(int)
    
    sess_slp = ld.sess_slp_load(sess) #  load sleep on/off times as np array
    if type(sess_slp) == list:
        sess_slp = np.array([[0,0],[0,0]])
    sess_slp = sess_slp.astype(int)
    
    sess_cells = cell_df.loc[cell_df.recording_id== sess]
    
    location = sess_cells.label.iloc[0]
    
    sess_dur = int(sess_cells.Duration.iloc[0])
    rat = sess_cells.Rat.iloc[0]
    
    namecount = 0
    
# Then iterate through each cell
    for cell in sess_spks: # cell = sess_spks[0]
        cell = [x for x in cell if x <= sess_dur] # any spikes at times after we have EEG should be excluded
        cell = np.array(cell)
        
        cell_szs = np.copy(sess_szs) # get a version of seizure and sleep times just for this cell
        cell_slp = np.copy(sess_slp)

        cell_szs = cell_szs[np.invert(np.any(cell_szs>sess_dur,axis=1)),:]    # get rid of any events that happen after our last spike  
        cell_slp = cell_slp[np.invert(np.any(cell_slp>sess_dur,axis=1)),:]
        
        cellname = sess_cells.iloc[namecount]['Name']
                
        location = sess_cells.iloc[namecount]['label']
        namecount += 1
        
        spk_log = np.zeros(sess_dur) # create a logical to align spikes with states
        spk_log[cell] = 1 # for every spike set the corresponding logical element to 1
  
        ISIs = np.diff(cell)
        ISIs = np.insert(ISIs,0,cell[0])
        missingend = ISIs>30000 # find times when there was no spiking for 30s or more, presuming cell was absent at these times 
        if sum(missingend)>0: #  if there were any such times
            missingstrt = np.roll(missingend,-1) # then find the location of spikes just before those
            
            missingspk0 = cell[missingstrt] # find the spike before the gap       
            missingspk1 = cell[missingend] #  and the spike after the gap
                    
            if missingspk0[0]>missingspk1[0]: #  if the first start is after the first end
                missingspk0=np.insert(missingspk0,0,0) #  then the real first start should be at zero
                missingspk0 = np.delete(missingspk0,-1) #  and get rid of the last 'start'
            missingspks = np.vstack([missingspk0,missingspk1]).transpose() #  put the starts and ends together
            for gap in missingspks: #  and iterate through them
                spk_log[gap[0]:gap[1]] = np.nan # to set each interval between a start and an end to nan
            
        onpad = np.empty(window) # create a padding array to make sure first seizure is at least one window from session start    
        onpad[:] = np.nan # set it to nan
        spk_log = np.insert(spk_log,0,onpad) # add it to the start of the spike logical
        spk_log = np.append(spk_log,onpad) # and to the end to make sure there's space there too       
        cell_szs += window # and add its length to the start and end times of seizures
        cell_slp += window

        sz_log = np.zeros(len(spk_log)).astype(int) # create a logical for all times in seizure
        for idx, seizure in enumerate(cell_szs): # for each seizure (row of seiz)
            sz_log[cell_szs[idx,0]:cell_szs[idx,1]] = 1 # set elements from start to end = 1

        slp_log = np.zeros(len(spk_log)).astype(int)
        for idx, sleep in enumerate(cell_slp): # for each sleep bout (row of slp)
            slp_log[cell_slp[idx,0]:cell_slp[idx,1]] = 1 # set elements from start to end = 1
        slp_log[sz_log.astype(bool)] = 0  #  any time designated seizure can't be sleep
        
        bl_log = np.ones(len(spk_log)).astype(int) # also a logical for all non-seizure, non-sleep, nonpre/post seizure times
        bl_log[sz_log.astype(bool)] = 0
        bl_log[slp_log.astype(bool)] = 0
        
        bl_fr = np.nanmean(spk_log[bl_log.astype(bool)])*1000 # mean baseline firing rate per second
      
        # and each seizure for that cell
        OnSpkTms = [] # create empty list (to hold times of spikes around each seizures start)
        OnWinLogs = np.empty([window*2]) # and an empty array to hold logs 
        Offsets = [] # and an empty list to hold offsets
        FirstSpks = np.empty(1)
        for seiz in cell_szs:
            szspkon_log = np.copy(spk_log) # get a version of the spike logical to use for just this seizure
            onesz_log = np.copy(sz_log)  # and a version of the seizure logical to use for this seizure
            onesz_log[seiz[0]:seiz[1]] = 0 # set so that all other seizure times are ones, and this seizure's times are zeros
            szspkon_log[onesz_log.astype(bool)] = np.nan # use that to set all other seizure times to nan in the spike log, which
            szspkon_log[0:seiz[0]-window] = np.nan # should only include spikes within one window of the start...
            szspkon_log[min(seiz[1],seiz[0]+window):-1] = np.nan # or up until the end of the seizure, whichever comes first
            szspkon_log[slp_log] = np.nan # exclude any spikes that occurred during sleep
            
            winspkon_log = szspkon_log[seiz[0]-window:seiz[0]+window] # get a logical of just the windows around seizure start
            if np.sum(np.isnan(winspkon_log)) == winspkon_log.size:
                continue
            
            OnWinLogs = np.vstack([OnWinLogs,winspkon_log])
            
            szspkoff_log = np.copy(spk_log) # get a version of the spike logical to use for just this seizure
            szspkoff_log[onesz_log] = np.nan # also get rid of spikes belonging to other seizures here
            szspkoff_log[0:max(seiz[0],seiz[1]-window)] = np.nan # for offset, should be nan up until seizure start or one window from end (whichever's later)
            szspkoff_log[seiz[1] + window:-1] = np.nan # and same from one window the end of the seizure
            szspkoff_log[slp_log] = np.nan # exclude any spikes that occurred during sleep
            
            onspks = szspkon_log[seiz[0]-window:seiz[0]+window] # extract the spikes around seizure start
            offspks = szspkoff_log[seiz[1]-window:seiz[1]+window] # and seizure end
            
            onspktms = np.squeeze(np.transpose(np.argwhere(onspks==1)))-window # find the locations of spikes around seizure start (for raster plot)
            try:
                firstspk = onspktms[np.amin(np.asarray(np.where(onspktms > 50)))]
            except:
                firstspk = 0
            FirstSpks = np.vstack([FirstSpks,firstspk])
            
            OnSpkTms.append(onspktms)
            offset = [np.argmax(np.isfinite(winspkon_log))-window,np.nanmax(np.argwhere(np.isfinite(winspkon_log)))-window+1] # and the range of the window around sz start (index of first & last finite value)
            Offsets.append(offset)
            binnedon = onspks.reshape((window*2/bin_size,bin_size))
            binnedoff = offspks.reshape((window*2/bin_size,bin_size))
            
            onfr = np.nanmean(binnedon,axis=1)*1000
            offfr = np.nanmean(binnedoff,axis=1)*1000

            onisis = np.empty(np.size(binnedon,0))
            offisis = np.empty(np.size(binnedoff,0))
            
            for idx, row in enumerate(binnedon):
                onisis[idx] = np.nanstd(np.diff(np.where(row==1)))/np.nanmean(np.diff(np.where(row==1)))
                # these lines find the locations of spikes in each bin, then the intervals between these locations, and finally the standard deviation of those intervals
                # in order to estimate how much inter-spike intervals vary. A lower value indicates more regularity.
            for idx, row in enumerate(binnedoff):
                offisis[idx] = np.nanstd(np.diff(np.where(row==1)))/np.nanmean(np.diff(np.where(row==1)))

#            SzTransFiringRates = SzTransFiringRates.append({'Start':onfr,'End':offfr,'Baseline':bl_fr,'Animal':rat,'Cell':cellname,'Type':location},ignore_index=True)
#            SzTransISIcov = SzTransISIcov.append({'Start':onisis,'End':offisis,'Animal':rat,'Cell':cellname,'Type':location},ignore_index=True)
#            
        
        OnWinLogs = np.delete(OnWinLogs,(0),axis=0)
        FirstSpks = np.delete(FirstSpks,(0),axis=0)
        
        # If there are no spikes around seizure start, move to the next cell
        if not OnSpkTms:
            continue
        
        # We need to get rid of any seizures that only had a single spike, or the plot won't work
        SpkCounts = np.array(map(np.size,OnSpkTms))
        OnWinLogs = OnWinLogs[SpkCounts>1,:]
        FirstSpks = FirstSpks[SpkCounts>1,:]
        OnSpkTms = list(itertools.compress(OnSpkTms,SpkCounts>1))
        Offsets = list(itertools.compress(Offsets,SpkCounts>1))
        
        SeizOrder = np.argsort(np.squeeze(FirstSpks).astype(int).tolist())
        SeizOrder = [i for i, v in sorted(enumerate(SeizOrder), key=lambda iv: iv[1])]
        
        SortSpkTms = [x for _,x in sorted(zip(SeizOrder,OnSpkTms))]
        SortOffsets = [x for _,x in sorted(zip(SeizOrder,Offsets))]
        # Please note that I sincerely apologize to anyone viewing this in the future for this
        #incredibly stupid workaround, that I'm pretty sure just goes back on itself
            
        if not SpkCounts.any():
            continue
        
        f = plt.figure(figsize=(10,10))# Create an empty figure to plot raster plus histogram
        ax1 = f.add_subplot(2,1,1)
        ax2 = f.add_subplot(2,1,2, sharex=ax1)
        ax3 = ax2.twinx()
        
        # First rasters
        lineoffsets1 = np.arange(1,len(OnWinLogs)+1,1)
        lineoffsets1 = np.concatenate((lineoffsets1,lineoffsets1))
        color_list = [[0,0,1],[1,0,0]] 
        color_choices = list(itertools.chain.from_iterable(itertools.repeat(x,len(OnWinLogs)) for x in color_list))
        line_list = [0.8,1]
        line_lengths = list(itertools.chain.from_iterable(itertools.repeat(x,len(OnWinLogs)) for x in line_list))
        ax1.eventplot(OnSpkTms+Offsets,lineoffsets=lineoffsets1,colors=color_choices,linelengths=line_lengths)

        # Then histogram
        counts = []
        n= []
        nbins=np.int64(window*2/100)
        for i in range(nbins):
            this_bin = OnWinLogs[:,i*bin_len:(i+1)*bin_len]
            n.append(len([value for value in np.array(Offsets) if value[0] <=(i*bin_len)-window and value[1] >= (i+1)*bin_len-window]))
            this_n = np.count_nonzero(~np.isnan(this_bin))
            if this_n <= 100:
                counts.append(0)
            else:
                counts.append(fs*np.nansum(this_bin)/this_n)
        x = np.arange(-window,window,bin_len)
        ax2.bar(x,counts,color=[0,0,1],align='edge',width=bin_len)
        ax3.plot(x+50,n,color=[0,1,0])        
        
        ax1.set_ylabel('Seizure', fontsize=25)
        ax2.set_ylabel('Spikes/Second',fontsize=25)
        ax2.set_xlabel('Seconds From Seizure Start',fontsize=25)
        ax3.set_ylabel('Number of Seizures',fontsize=25, color='#42FF33', rotation=270, labelpad=20)
        ax3.set_ylim(bottom=0)
        ax3.yaxis.set_major_locator(MaxNLocator(3,integer=True))
        nameparts = cellname.split('_')
        strttime = nameparts[2].split('.')[0]
        f.suptitle('Seizure Spiking for Cell ' + nameparts[1] + ' ' + strttime,fontsize=25)
        xlabs = ax1.get_xticks()
        ax1.set_xticklabels((xlabs/fs).astype(int))
        
        plt.text(0.01, 0.01, 'McCafferty et al.', fontsize=15, transform=plt.gcf().transFigure)
        
        try:
            cellclust = assignments[assignments["Cell"]==cellname]["Classes"].tolist()[0]
        except:
            cellclust = 'Miscellaneous'   
        
        figname = '/mnt/Data4/MakeFigures/TestForOD/CellSpikingRasterHist/'+location+'/'+cellclust.replace(" ","")+"/"+cellname+'.tif'
        f.savefig(home+figname)
        plt.close(f)
        print("Saving " + cellname + " to " + cellclust + " group")

SzTransISIcov.to_pickle(home+'/mnt/Data4/MakeFigures/TestForOD/SzTransISIcov_SzOnOff.pkl')            
SzTransFiringRates.to_pickle(home+'/mnt/Data4/MakeFigures/TestForOD/SzTransFiringRates_SzOnOff.pkl')
    
# After extracting the data, we will take averages by seizure and by cell

# First line just re-loads the pickled file (start from here if possible)
SzTransFiringRates = pd.read_pickle(home+'/mnt/Data4/MakeFigures/TestForOD/SzTransFiringRates_StateMedRes.pkl')
SzTransISIcov = pd.read_pickle(home+'/mnt/Data4/MakeFigures/TestForOD/SzTransISIcov_StateMedRes.pkl')

window = 120000
bin_size = 2000
# For the (hopefully) final two versions of the dataframes, the resolutions are as follows:
# SzOnOff (peri-seizure): 10000 ms window with 500 ms resolution, or 2000 ms resolution for rhythmicity
# StateMedRes (pre-seiz state)" 120000 ms window with 2000 ms resolution

locations = SzTransFiringRates.Type.unique()

xmarkinterval = 20 # the space between tick marks on the final x axis (5 for transitions, 20 for state)

steps = float(bin_size)/fs # intervals between x values in seconds (number of samples per point divided by number of samples per second)
bincount = window/fs # number of bins/x points in the data (length of window/epoch in ms divided by number of ms per bin)
start = -(bincount) # first x value relative to seizure start time ()
stop = bincount+1 # last x value relative to seizure start time
xvals = np.arange(start,stop,steps) # all x values (from first to last)

szrange = np.min([20,window/fs]) # we want to plot only 20s of seizure at most, as over that the sample size plummets

xvalson = np.arange(0,bincount+szrange,steps) # seizure on x values start at zero and run for one window's worth of bins (pre-seiz) plus the range within seizure we want to plot (in bins)
xvalsoff = np.arange(np.max(xvalson)+xmarkinterval,np.max(xvalson)+xmarkinterval+szrange+bincount,steps)
# Above: seiz off x vals start one interval above the last on value, and again run for one seizure range's worth of bins plus one window's worth of bins
zeroon = xvalson[int(bincount/steps)] # seizure on will be one window into the "on" x values
zerooff = xvalsoff[int(szrange/steps)] # while seizure off will be one seizure range into the "off" x values

slopewin = [bincount-80,bincount-10] # windows over which correlation coefficients will be calculated
# note that these only apply to the state variables (not short window peri-seizure)


xticklocs = np.hstack([np.arange(xvalson[0],xvalson[-1]+xmarkinterval,xmarkinterval),np.arange(xvalsoff[0],xvalsoff[-1]+xmarkinterval,xmarkinterval)])
# locations for x axis ticks will be every nth value from the on and off x vals, where n is the desired tick interval divided by the size of each step
xtickvals = np.hstack([np.arange(start,szrange+1,xmarkinterval),np.arange(-szrange,stop,xmarkinterval)])
# values for x axis ticks will be 

for location in locations:
    TransFR = SzTransFiringRates.loc[SzTransFiringRates.Type == location]
#    TransFR = SzTransISIcov.loc[SzTransISIcov.Type == location]
    SzStartRawFR = TransFR.Start
    SzStartRawFR = np.array(SzStartRawFR.tolist()) # These are just some shenanigans to get values into numpy array
    
    SzEndRawFR = TransFR.End
    SzEndRawFR = np.array(SzEndRawFR.tolist()) # These are just some shenanigans to get values into numpy array
    
    yvals = np.nanmean(SzStartRawFR[:,0:int((bincount+szrange)/steps)],axis=0)
    yerr = ss.sem(SzStartRawFR[:,0:int((bincount+szrange)/steps)],axis=0,nan_policy='omit')
    plt.figure()
    plt.plot(xvalson,yvals,color='b')
    plt.fill_between(xvalson,yvals-yerr,yvals+yerr,color='lightblue')
    plt.axvline(x=zeroon,color='r');
#        plt.ylim([np.nanmin(yvals-yerr)-2,np.nanmax(yvals+yerr)+2])
    
    yvals = np.nanmean(SzEndRawFR[:,-int((bincount+szrange)/steps):],axis=0)
    yerr = ss.sem(SzEndRawFR[:,-int((bincount+szrange)/steps):],axis=0,nan_policy='omit')
    plt.plot(xvalsoff,yvals,color='b')
    plt.fill_between(xvalsoff,yvals-yerr,yvals+yerr,color='lightblue')
    plt.axvline(x=zerooff,color='r')
    plt.ylabel('Firing Rate (Hz)')
#    plt.ylabel('Inter-Spike Interval variability (ms)')
    plt.xlabel('Time from Seizure End (s)')
    plt.title([location + ' by seiz'])
    plt.xticks(xticklocs,xtickvals)
#    plt.gca().invert_yaxis() # use only for ISI coefficient of variation
    
    # Calculating mean firing rates up to 5 s pre-seizure (transitions only, not state)
#    preszrate = np.nanmean(SzStartRawFR[:,0:int((bincount-5)/steps)],axis=1) # From start of data to 5s before seizure start time
#    szrate = np.nanmean(SzStartRawFR[:,int(bincount/steps):int((bincount+szrange)/steps)],axis=1)
#    preszsem = ss.sem(preszrate,nan_policy='omit')
#    szsem = ss.sem(szrate,nan_policy='omit')

#    w,p = ss.ttest_rel(preszrate,szrate,nan_policy='omit')

#    print(location + ' baseline = ' + 
#          str(np.around(np.nanmean(preszrate),decimals=3)) + ', SEM = ' +
#          str(np.around(preszsem,decimals=3)))
#    print(location + ' seizure = ' + 
#          str(np.around(np.nanmean(szrate),decimals=3)) + ', SEM = ' +
#          str(np.around(szsem,decimals=3)))
#    print(location + ' base v seiz p = ' +
#        str(p))
 

    CellStartRawFR = np.empty([1,np.size(xvalson,0)])
    CellEndRawFR = np.empty([1,np.size(xvalson,0)])
    CellStartNormFR = np.empty([1,np.size(xvalson,0)])
    CellEndNormFR = np.empty([1,np.size(xvalson,0)])

    for cell in TransFR.Cell.unique():
        # Use first definitions of oncellfr and offcellfr (1-line) if looking at FR, second definitions (3-line) if looking at ISI covar
        oncellfr = np.nanmean(np.array(SzTransFiringRates.loc[SzTransFiringRates.Cell==cell].Start.tolist())[:,0:int((bincount+szrange)/steps)],axis=0)
#        oncellfr = np.nanmean(np.array(SzTransISIcov.loc[SzTransISIcov.Cell==cell].Start.tolist())[:,0:int((bincount+szrange)/steps)],axis=0)
#        oncellfr[oncellfr==0]= np.nan
#        oncellfr = 1/(oncellfr)
        CellStartRawFR=np.vstack([CellStartRawFR, oncellfr])
        offcellfr = np.nanmean(np.array(SzTransFiringRates.loc[SzTransFiringRates.Cell==cell].End.tolist())[:,-int((bincount+szrange)/steps):],axis=0)
#        offcellfr = np.nanmean(np.array(SzTransISIcov.loc[SzTransISIcov.Cell==cell].End.tolist())[:,-int((bincount+szrange)/steps):],axis=0)
#        offcellfr[offcellfr==0]= np.nan
#        offcellfr = 1/(offcellfr)
        CellEndRawFR=np.vstack([CellEndRawFR,offcellfr])
        CellStartNormFR=np.vstack([CellStartNormFR, oncellfr/np.nanmax(np.abs(np.append(oncellfr,offcellfr)),axis=0)])
        CellEndNormFR = np.vstack([CellEndNormFR, offcellfr/np.nanmax(np.abs(np.append(oncellfr,offcellfr)),axis=0)])
        
    CellStartRawFR = np.delete(CellStartRawFR, (0), axis=0)    
    CellEndRawFR = np.delete(CellEndRawFR, (0), axis=0)    
    CellStartNormFR = np.delete(CellStartNormFR, (0), axis=0)    
    CellEndNormFR = np.delete(CellEndNormFR, (0), axis=0)    
       
    yvals = np.nanmean(CellStartNormFR,axis=0)
    yerr = ss.sem(CellStartNormFR,axis=0,nan_policy='omit')
    plt.figure()
    plt.plot(xvalson,yvals,color='b')
    plt.fill_between(xvalson,yvals-yerr,yvals+yerr,color='lightblue')
    plt.axvline(x=zeroon,color='r')
    
    yvals = np.nanmean(CellEndNormFR,axis=0)
    yerr = ss.sem(CellEndNormFR,axis=0,nan_policy='omit')
    plt.plot(xvalsoff,yvals,color='b')
    plt.fill_between(xvalsoff,yvals-yerr,yvals+yerr,color='lightblue')
    plt.axvline(x=zerooff,color='r')
    plt.ylabel('Firing Rate (Proportion of Cell Max)')
#    plt.ylabel('Inter-Spike Interval Covariance (Proportion of Cell Max)')
    plt.xlabel('Time from Seizure Start (s)')
    plt.title([location+' normalized by cell'])
    plt.xticks(xticklocs,xtickvals)
#    plt.gca().invert_yaxis()

    # Testing correlation coefficients between pre-seizure  rates and time
    preYs = np.nanmean(CellStartNormFR[:,int(slopewin[0]/steps):int(slopewin[1]/steps)],axis=0)
    r,p = ss.pearsonr(xvals[int(slopewin[0]/steps):int(slopewin[1]/steps)],preYs)
    plt.text(1, 0.05, ['p = '+ str(p)])
    
    print(location + ' ' + pattern + ' -80 to -10 R = ' + 
      str(np.around(r,decimals=3)) + ', p = ' +
      str(p))

    
    yvals = np.nanmean(CellStartRawFR,axis=0)
    yerr = ss.sem(CellStartRawFR,axis=0,nan_policy='omit')
    plt.figure()
    plt.plot(xvalson,yvals,color='b')
    plt.fill_between(xvalson,yvals-yerr,yvals+yerr,color='lightblue')
    plt.axvline(x=zeroon,color='r')
#        plt.ylim([np.nanmin(yvals-yerr)-2,np.nanmax(yvals+yerr)+2])
    
    yvals = np.nanmean(CellEndRawFR,axis=0)
    yerr = ss.sem(CellEndRawFR,axis=0,nan_policy='omit')
    plt.plot(xvalsoff,yvals,color='b')
    plt.fill_between(xvalsoff,yvals-yerr,yvals+yerr,color='lightblue')
    plt.axvline(x=zerooff,color='r')
    plt.ylabel(' Firing Rate')
#    plt.ylabel('Inter-Spike Interval Covariance')
    plt.xlabel('Time from Seizure End (s)')
    plt.title([location + ' by cell'])
    plt.xticks(xticklocs,xtickvals)
#    plt.gca().invert_yaxis()
    
    # Calculating mean firing rates up to 5 s pre-seizure (transitions only, not state) for cell-wise data
    preszrate = np.nanmean(CellStartRawFR[:,0:int((bincount-5)/steps)],axis=1) # From start of data to 5s before seizure start time
    szrate = np.nanmean(CellStartRawFR[:,int(bincount/steps):int((bincount+szrange)/steps)],axis=1)
    preszsem = ss.sem(preszrate,nan_policy='omit')
    szsem = ss.sem(szrate,nan_policy='omit')

    w,p = ss.ttest_rel(preszrate,szrate,nan_policy='omit')

    print(location + ' baseline = ' + 
          str(np.around(np.nanmean(preszrate),decimals=3)) + ', SEM = ' +
          str(np.around(preszsem,decimals=3)))
    print(location + ' seizure = ' + 
          str(np.around(np.nanmean(szrate),decimals=3)) + ', SEM = ' +
          str(np.around(szsem,decimals=3)))
    print(location + ' base v seiz p = ' +
        str(p))


# Testing correlation coefficients between 1 min pre-seizure firing rates and time



# Next bit is calculating autocorrelograms ~


from numpy.lib.stride_tricks import as_strided


def _check_arg(x, xname):
    x = np.asarray(x)
    if x.ndim != 1:
        raise ValueError('%s must be one-dimensional.' % xname)
    return x

def autocorrelation(x, maxlag):
    """
    Autocorrelation with a maximum number of lags.

    `x` must be a one-dimensional numpy array.

    This computes the same result as
        numpy.correlate(x, x, mode='full')[len(x)-1:len(x)+maxlag]

    The return value has length maxlag + 1.
    """
    x = _check_arg(x, 'x')
    p = np.pad(x.conj(), maxlag, mode='constant')
    T = as_strided(p[maxlag:], shape=(maxlag+1, len(x) + maxlag),
                   strides=(-p.strides[0], p.strides[0]))
    return T.dot(p[maxlag:].conj())


CellXCorrs = pd.DataFrame([],columns=['Rat','Cell','SeizXCorr','BaselineXCorr'])
counter = 0
cortcell_df = database.loc[(database.Type == 'Cell') & (database.label == 'Cortical')]

for cell in cortcell_df.Name:# for every cell

## Load data first
    sess = cortcell_df.recording_id[counter]    
    
    spks = np.array(ld.single_cell_load(cell)) # load those spikes
    
    sess_szs = (ld.sess_seiz_load(sess)).astype(int)
    
    sess_slp = ld.sess_slp_load(sess) #  load sleep on/off times as np array
    if type(sess_slp) == list:
        sess_slp = np.array([[0,0],[0,0]])
    sess_slp = sess_slp.astype(int)
    
    sess_cells = cortcell_df.loc[cortcell_df.recording_id== sess]
    
    sess_dur = int(sess_cells.Duration.iloc[0])
    rat = sess_cells.Rat.iloc[0]
    spks = [x for x in spks if x <= sess_dur] # any spikes at times after we have EEG should be excluded
    spks = np.array(spks)    
    
## Then create logicals
    cell_szs = np.copy(sess_szs) # get a version of seizure and sleep times just for this cell
    cell_slp = np.copy(sess_slp)

    cell_szs = cell_szs[np.invert(np.any(cell_szs>sess_dur,axis=1)),:]    # get rid of any events that happen after our last spike  
    cell_slp = cell_slp[np.invert(np.any(cell_slp>sess_dur,axis=1)),:]
        
    
    spk_log = np.zeros(sess_dur) # create a logical to align spikes with states
    spk_log[spks] = 1 # for every spike set the corresponding logical element to 1
  
    ISIs = np.diff(spks)
    ISIs = np.insert(ISIs,0,spks[0])
    missingend = ISIs>30000 # find times when there was no spiking for 20s or more, presuming cell was absent at these times 
    if sum(missingend)>0: #  if there were any such times
        missingstrt = np.roll(missingend,-1) # then find the location of spikes just before those
            
        missingspk0 = spks[missingstrt] # find the spike before the gap       
        missingspk1 = spks[missingend] #  and the spike after the gap
                    
        if missingspk0[0]>missingspk1[0]: #  if the first start is after the first end
            missingspk0=np.insert(missingspk0,0,0) #  then the real first start should be at zero
            missingspk0 = np.delete(missingspk0,-1) #  and get rid of the last 'start'
        missingspks = np.vstack([missingspk0,missingspk1]).transpose() #  put the starts and ends together
        for gap in missingspks: #  and iterate through them
            spk_log[gap[0]:gap[1]] = np.nan # to set each interval between a start and an end to nan
        

    sz_log = np.zeros(len(spk_log)).astype(int) # create a logical for all times in seizure
    for idx, seizure in enumerate(cell_szs): # for each seizure (row of seiz)
        sz_log[cell_szs[idx,0]:cell_szs[idx,1]] = 1 # set elements from start to end = 1

    slp_log = np.zeros(len(spk_log)).astype(int)
    for idx, sleep in enumerate(cell_slp): # for each sleep bout (row of slp)
        slp_log[cell_slp[idx,0]:cell_slp[idx,1]] = 1 # set elements from start to end = 1
    slp_log[sz_log.astype(bool)] = 0  #  any time designated seizure can't be sleep
    
    bl_log = np.ones(len(spk_log)).astype(int) # also a logical for all non-seizure, non-sleep, nonpre/post seizure times
    bl_log[sz_log.astype(bool)] = 0
    bl_log[slp_log.astype(bool)] = 0

    szspk_log = spk_log[sz_log.astype('bool')] # takes only spikes during seizure
    blspk_log = spk_log[bl_log.astype('bool')] # or during baseline
    
    szspk_log = szspk_log[np.isfinite(szspk_log)]   # get rid of any remaining nans 
    blspk_log = blspk_log[np.isfinite(blspk_log)]   # get rid of any remaining nans 
    

    szautocorr = autocorrelation(szspk_log,200)
    blautocorr = autocorrelation(blspk_log,200)
    
    CellXCorrs = CellXCorrs.append({'Cell':cell,'Rat':rat, 'SeizXCorr':szautocorr, 'BaselineXCorr':blautocorr},ignore_index=True)
    counter += 1
    
# Then plot autocorrs
    
MeanSzAutoCorr = CellXCorrs.SeizXCorr
MeanSzAutoCorr = np.array(MeanSzAutoCorr.tolist())
MeanSzAutoCorr = MeanSzAutoCorr/np.nanmean(MeanSzAutoCorr,axis=0)[0]
MeanSzAutoCorr = MeanSzAutoCorr[:,1:]


yvals = np.concatenate((np.flip(np.nanmean(MeanSzAutoCorr,axis=0)),np.nanmean(MeanSzAutoCorr,axis=0)))
yerr = np.concatenate((np.flip(ss.sem(MeanSzAutoCorr,axis=0)),ss.sem(MeanSzAutoCorr,axis=0)))
xvals = np.arange(-200,200,1)

plt.figure()
plt.plot(xvals,yvals,color='r')
plt.fill_between(xvals,yvals-yerr,yvals+yerr,color='pink')
plt.ylabel('Spike Autocorrelation (probability per ms)')
plt.xlabel('Time offset (ms)')



MeanBlAutoCorr = CellXCorrs.BaselineXCorr
MeanBlAutoCorr = np.array(MeanBlAutoCorr.tolist())
MeanBlAutoCorr = MeanBlAutoCorr/np.nanmean(MeanBlAutoCorr,axis=0)[0]
MeanBlAutoCorr = MeanBlAutoCorr[:,1:]


yvals = np.concatenate((np.flip(np.nanmean(MeanBlAutoCorr,axis=0)),np.nanmean(MeanBlAutoCorr,axis=0)))
yerr = np.concatenate((np.flip(ss.sem(MeanBlAutoCorr,axis=0)),ss.sem(MeanBlAutoCorr,axis=0)))
xvals = np.arange(-200,200,1)

plt.figure()
plt.plot(xvals,yvals,color='orange')
plt.fill_between(xvals,yvals-yerr,yvals+yerr,color='gold')
plt.ylabel('Spike Autocorrelation (probability per ms)')
plt.xlabel('Time offset (ms)')

# Plotting pSWCth
# First, load (as created by plot_SWC_triggered_avg.py, function plot_SWC_avg)

with open(home+'/mnt/Data4/MakeFigures/TestForOD/baseline_pSWCth.pkl') as f3:
    pSWCth_bl = pk.load(f3)

with open(home+'/mnt/Data4/MakeFigures/TestForOD/seizure_pSWCth.pkl') as f4:
    pSWCth_sz = pk.load(f4)

with open(home+'/mnt/Data4/MakeFigures/TestForOD/szstart_pSWCth.pkl') as f5:
    pSWCth_strt = pk.load(f5)


pSWCth_bl = pSWCth_bl[['Cell','Baseline']]
pSWCth = pSWCth_sz.merge(pSWCth_bl,left_on = 'Cell', right_on = 'Cell')

pSWCth_strt = pSWCth_strt[['Cell','Rest','Start']]
pSWCth = pSWCth.merge(pSWCth_strt,left_on = 'Cell', right_on = 'Cell')

# Then find locations

locations = pSWCth.Type.unique()

# And then set up peak and troughs (as derived from figures)

PT_ctx_1s = np.array([78,103,173,198,104,172])
PT_ctx_all = np.array([58,77,179,198,78,178])
PT_thl_1s = np.array([68,89,173,194,90,172])
PT_thl_all = np.array([43,68,173,192,69,172])

#PT_ctx_1s_2 = np.array([-63,-27,13,56,-26,12])+200
#PT_ctx_all_2 = np.array([-68,-23,10,62,-22,9])+200
#PT_thl_1s_2 = np.array([-75,-28,16,56,-27,15])+200
#PT_thl_all_2 = np.array([-82,-28,11,61,-27,10])+200
# These second set are from trough to trough (so 2 trough regions) rather than peak to peak

PT = pd.DataFrame(index=locations,columns=['First Second','All Seizure'])
PT.set_value('Cortical','First Second',PT_ctx_1s)
PT.set_value('Cortical','All Seizure',PT_ctx_all)
PT.set_value('Thalamic','First Second',PT_thl_1s)
PT.set_value('Thalamic','All Seizure',PT_thl_all)

jitter = 0.05

for location in locations:
    loc_pSWCth = pSWCth.loc[pSWCth.Type == location]

    Sz_pSWCth = loc_pSWCth.AllSeizures
    Sz_pSWCth = np.array(Sz_pSWCth.tolist())
    
#    yvals = np.nanmean(Sz_pSWCth,axis=0)*1000
#    yerr = ss.sem(Sz_pSWCth,axis=0)*1000
#    xvals = np.arange(-200,200,1)
    
#    plt.figure()
#    plt.plot(xvals,yvals,color='r')
#    plt.fill_between(xvals,yvals-yerr,yvals+yerr,color='pink')
#    plt.ylabel('Spikes per Second')
#    plt.xlabel('Time from SWC Peak (ms)')
    
    # and baseline (sham) pSWCth
    Bl_pSWCth = loc_pSWCth.Baseline
    Bl_pSWCth = np.array(Bl_pSWCth.tolist())
    
#    yvals = np.nanmean(Bl_pSWCth,axis=0)*1000
#    yerr = ss.sem(Bl_pSWCth,axis=0)*1000
#    xvals = np.arange(-200,200,1)
#    
#    plt.plot(xvals,yvals,color='orange')
#    plt.fill_between(xvals,yvals-yerr,yvals+yerr,color='gold')
#    plt.ylabel('Spikes per Second')
#    plt.xlabel('Time from SWC Peak (ms)')
    
    # and first second of seizure pSWCth
    Strt_pSWCth = loc_pSWCth.Start
    Strt_pSWCth = np.array(Strt_pSWCth.tolist())
    
#    yvals = np.nanmean(Strt_pSWCth,axis=0)*1000
#    yerr = ss.sem(Strt_pSWCth,axis=0)*1000
#    xvals = np.arange(-200,200,1)
#    
#    plt.plot(xvals,yvals,color='seagreen')
#    plt.fill_between(xvals,yvals-yerr,yvals+yerr,color='springgreen')
#    plt.ylabel('Spikes per Second')
#    plt.xlabel('Time from SWC Peak (ms)')
    
    # and rest of seizure pSWCth
    Rest_pSWCth = loc_pSWCth.Rest
    Rest_pSWCth = np.array(Rest_pSWCth.tolist())
    
#    yvals = np.nanmean(Rest_pSWCth,axis=0)*1000
#    yerr = ss.sem(Rest_pSWCth,axis=0)*1000
#    xvals = np.arange(-200,200,1)
#    
#    plt.plot(xvals,yvals,color='black')
#    plt.fill_between(xvals,yvals-yerr,yvals+yerr,color='lightgray')
#    plt.ylabel('Spikes per Second')
#    plt.xlabel('Time from SWC Peak (ms)')
#    
#    plt.yticks(np.arange(0,35,10))
#    plt.xticks(np.arange(-200,210,100))
    
    # now calculate the total firing (sum) during designated peak and trough periods in each cell's pSWCth 
    
    troughs = np.nansum(Sz_pSWCth[:,PT['All Seizure'].loc[location][4]:PT['All Seizure'].loc[location][5]],axis=1) #trough firing is all spikes within the trough location during seizure
    basetrgh = np.nansum(Bl_pSWCth[:,PT['All Seizure'].loc[location][4]:PT['All Seizure'].loc[location][5]],axis=1) #baseling trough firing is all spikes within the trough location at baseline
    peaks = np.nansum(np.hstack([Sz_pSWCth[:,PT['All Seizure'].loc[location][0]:PT['All Seizure'].loc[location][1]],Sz_pSWCth[:,PT['All Seizure'].loc[location][2]:PT['All Seizure'].loc[location][3]]]),axis=1)
    basepk = np.nansum(np.hstack([Bl_pSWCth[:,PT['All Seizure'].loc[location][0]:PT['All Seizure'].loc[location][1]],Bl_pSWCth[:,PT['All Seizure'].loc[location][2]:PT['All Seizure'].loc[location][3]]]),axis=1)
    
    # the next lines calculate the surplus firing during peaks and deficit in firing during troughs for each cell
    surplus = peaks-basepk
    deficit = (troughs-basetrgh)*-1
    

    data = pd.melt(pd.DataFrame({"Surplus":surplus, "Deficit":deficit}), var_name = 'Location', value_name = 'Firing')
        
    w,p=ss.ttest_rel(surplus,deficit,nan_policy='omit')
    
    print(location + ' Full Seizure peak surplus = ' + 
        str(np.around(np.nanmean(surplus),decimals=2)) + ', SEM = ' +
        str(np.around(ss.sem(surplus,nan_policy='omit'),decimals=2)))
    print(location + ' Full Seizure trough deficit = ' +
          str(np.around(np.nanmean(deficit),decimals=2)) + ', SEM = ' +
          str(np.around(ss.sem(deficit,nan_policy='omit'),decimals=2)))
    print(location + ' Surplus v Deficit Wilcoxon p = ' +
          str(np.around(p,decimals=10)) + ', rank sum = ' +
          str(np.around(w,decimals=2)))
    
    
    troughs1 = np.nansum(Strt_pSWCth[:,PT['First Second'].loc[location][4]:PT['First Second'].loc[location][5]],axis=1)
    basetrgh1 = np.nansum(Bl_pSWCth[:,PT['First Second'].loc[location][4]:PT['First Second'].loc[location][5]],axis=1)
    peaks1 = np.nansum(np.hstack([Strt_pSWCth[:,PT['First Second'].loc[location][0]:PT['First Second'].loc[location][1]],Strt_pSWCth[:,PT['First Second'].loc[location][2]:PT['First Second'].loc[location][3]]]),axis=1)
    basepk1 = np.nansum(np.hstack([Bl_pSWCth[:,PT['First Second'].loc[location][0]:PT['First Second'].loc[location][1]],Bl_pSWCth[:,PT['First Second'].loc[location][2]:PT['First Second'].loc[location][3]]]),axis=1)
    
    # the next lines calculate the surplus firing during peaks and deficit in firing during troughs for each cell *in the first second*
    surplus1 = peaks1-basepk1
    deficit1 = (troughs1-basetrgh1)*-1

    fig, ax = plt.subplots()
    
    offset = 0
   
    x_jitter1 = pd.Series(np.random.normal(loc=0, scale=jitter, size=surplus.shape))+offset
    ax.plot(x_jitter1, surplus, 'o', alpha=.40, zorder=1, ms=8, mew=1, color='r')
    ax.plot([offset-0.2,offset+0.2],[np.mean(surplus),np.mean(surplus)],'k-')
    ax.plot([offset-0.1,offset+0.1],[np.mean(surplus)+ss.sem(surplus),np.mean(surplus)+ss.sem(surplus)],'k-')
    ax.plot([offset-0.1,offset+0.1],[np.mean(surplus)-ss.sem(surplus),np.mean(surplus)-ss.sem(surplus)],'k-')
    ax.plot([offset,offset],[np.mean(surplus)-ss.sem(surplus),np.mean(surplus)+ss.sem(surplus)],'k-')
    
    offset += 1
   
    x_jitter1 = pd.Series(np.random.normal(loc=0, scale=jitter, size=surplus1.shape))+offset
    ax.plot(x_jitter1, surplus1, 'o', alpha=.40, zorder=1, ms=8, mew=1, color='b')
    ax.plot([offset-0.2,offset+0.2],[np.mean(surplus1),np.mean(surplus1)],'k-')
    ax.plot([offset-0.1,offset+0.1],[np.mean(surplus1)+ss.sem(surplus1),np.mean(surplus1)+ss.sem(surplus1)],'k-')
    ax.plot([offset-0.1,offset+0.1],[np.mean(surplus1)-ss.sem(surplus1),np.mean(surplus1)-ss.sem(surplus1)],'k-')
    ax.plot([offset,offset],[np.mean(surplus1)-ss.sem(surplus1),np.mean(surplus1)+ss.sem(surplus1)],'k-')

    offset+=1
    
    x_jitter2 = pd.Series(np.random.normal(loc=0, scale=jitter, size=deficit.shape))+offset
    ax.plot(x_jitter2, deficit, 'o', alpha=.40, zorder=1, ms=8, mew=1, color='r')
    ax.plot([offset-0.2,offset+0.2],[np.mean(deficit),np.mean(deficit)],'k-')
    ax.plot([offset-0.1,offset+0.1],[np.mean(deficit)+ss.sem(deficit),np.mean(deficit)+ss.sem(deficit)],'k-')
    ax.plot([offset-0.1,offset+0.1],[np.mean(deficit)-ss.sem(deficit),np.mean(deficit)-ss.sem(deficit)],'k-')
    ax.plot([offset,offset],[np.mean(deficit)-ss.sem(deficit),np.mean(deficit)+ss.sem(deficit)],'k-')
 
    offset+=1
    
    x_jitter2 = pd.Series(np.random.normal(loc=0, scale=jitter, size=deficit1.shape))+offset
    ax.plot(x_jitter2, deficit1, 'o', alpha=.40, zorder=1, ms=8, mew=1, color='b')
    ax.plot([offset-0.2,offset+0.2],[np.mean(deficit1),np.mean(deficit1)],'k-')
    ax.plot([offset-0.1,offset+0.1],[np.mean(deficit1)+ss.sem(deficit1),np.mean(deficit1)+ss.sem(deficit1)],'k-')
    ax.plot([offset-0.1,offset+0.1],[np.mean(deficit1)-ss.sem(deficit1),np.mean(deficit1)-ss.sem(deficit1)],'k-')
    ax.plot([offset,offset],[np.mean(deficit1)-ss.sem(deficit1),np.mean(deficit1)+ss.sem(deficit1)],'k-')
    
    ax.set_xticks(np.arange(0,offset+1)[0::2]+0.5)
    ax.set_xticklabels(['Peak Surplus','Trough Deficit'])
    fig.suptitle(location + ' Spikes Per Cycle')

    data = pd.melt(pd.DataFrame({"Surplus":surplus1, "Deficit":deficit1}), var_name = 'Location', value_name = 'Firing')
            
    w,p=ss.ttest_rel(surplus1,deficit1,nan_policy='omit')
    wp,pp = ss.ttest_rel(surplus,surplus1,nan_policy='omit')
    wt,pt = ss.ttest_rel(deficit,deficit1,nan_policy='omit')
    
    print(location + ' First Second peak surplus = ' + 
        str(np.around(np.nanmean(surplus1),decimals=2)) + ', SEM = ' +
        str(np.around(ss.sem(surplus1,nan_policy='omit'),decimals=2)))
    print(location + ' First Second trough deficit = ' +
          str(np.around(np.nanmean(deficit1),decimals=2)) + ', SEM = ' +
          str(np.around(ss.sem(deficit1,nan_policy='omit'),decimals=2)))
    print(location + ' Surplus v Deficit Wilcoxon p = ' +
          str(np.around(p,decimals=10)) + ', rank sum = ' +
          str(np.around(w,decimals=2)))
    
    print(location + ' First v Entire Surplus p = ' +
          str(np.around(pp,decimals=10)) + ', state = ' +
          str(np.around(wp,decimals=10)))
    print(location + ' First v Entire Deficit p = ' +
          str(np.around(pt,decimals=10)) + ', state = ' +
          str(np.around(wt,decimals=10)))
    
    
    # This section is designed to find the frequency of peaks in each cell's distribution
    #by first smoothing the distribution, finding peaks (with a minimum interval of 100ms)
    #and then getting the difference between the peaks
    
    Sz_freqs = np.empty([1,1])
    Sz_cycs = np.empty([1,1])
    Sz_pks = np.empty([1,3])
    for cell in Sz_pSWCth:
        smoothsz = sig.savgol_filter(cell,21,5)# smooths each individual total seizure distribution
        pks,_ = sig.find_peaks(smoothsz,distance=110) # assuming the minimum peak difference is 120 ms
        if pks.size==3 and np.abs(np.diff(np.diff(pks)))[0] < 10: # check that it can detect the expected number of peaks and that the inter-peak difference remains consistent within 10 ms
            frq = 1000/np.nanmean(np.diff(pks))
            cycle = np.nansum(cell[pks[0]:pks[1]])
        else:
#            print('Wrong Peak Detection')
            pks = np.empty((1,3))
            pks[:]= np.nan
            cycle = np.nan
            frq = np.nan
        Sz_pks = np.vstack([Sz_pks,pks])
        Sz_freqs= np.vstack([Sz_freqs,frq])
        Sz_cycs = np.vstack([Sz_cycs,cycle])
            

    Sz_freqs = np.squeeze(np.delete(Sz_freqs, (0), axis=0)) # just getting rid of the empty first elements
    Sz_cycs = np.delete(Sz_cycs, (0), axis=0)
    Sz_pks = np.delete(Sz_pks, (0), axis=0)
    #finds the locations of peaks
    #finds the intervals of peaks in ms and then divides 1000 by the result to get freq in Hz
        
    Strt_freqs = np.empty([1,1])
    Strt_cycs = np.empty([1,1])
    Strt_pks = np.empty([1,3])
    for cell in Strt_pSWCth:
        smoothsz = sig.savgol_filter(cell,21,5)# smooths each individual total seizure distribution
        pks,_ = sig.find_peaks(smoothsz,distance=110) # assuming the minimum peak difference is 120 ms
        if pks.size==3 and np.abs(np.diff(np.diff(pks)))[0] < 10:
            frq = 1000/np.nanmean(np.diff(pks))
            cycle = np.nansum(cell[pks[0]:pks[1]])
        else:
#            print('Wrong Peak Detection')
            pks = np.empty((1,3))
            pks[:]= np.nan
            cycle = np.nan
            frq = np.nan
        Strt_pks = np.vstack([Strt_pks,pks])
        Strt_freqs= np.vstack([Strt_freqs,frq])
        Strt_cycs = np.vstack([Strt_cycs,cycle])
            

    Strt_freqs = np.squeeze(np.delete(Strt_freqs, (0), axis=0))
    Strt_cycs = np.delete(Strt_cycs, (0), axis=0)
    Strt_pks = np.delete(Strt_pks, (0), axis=0)
    #finds the locations of peaks
    #finds the intervals of peaks in ms and then divides 1000 by the result to get freq in Hz
    
    fig, ax = plt.subplots()
    
    offset = 0
   
    x_jitter1 = pd.Series(np.random.normal(loc=0, scale=jitter, size=Sz_freqs.shape))+offset
    ax.plot(x_jitter1, Sz_freqs, 'o', alpha=.40, zorder=1, ms=8, mew=1, color='r')
    ax.plot([offset-0.2,offset+0.2],[np.nanmean(Sz_freqs),np.nanmean(Sz_freqs)],'k-')
    ax.plot([offset-0.1,offset+0.1],[np.nanmean(Sz_freqs)+ss.sem(Sz_freqs,nan_policy='omit'),np.nanmean(Sz_freqs)+ss.sem(Sz_freqs,nan_policy='omit')],'k-')
    ax.plot([offset-0.1,offset+0.1],[np.nanmean(Sz_freqs)-ss.sem(Sz_freqs,nan_policy='omit'),np.nanmean(Sz_freqs)-ss.sem(Sz_freqs,nan_policy='omit')],'k-')
    ax.plot([offset,offset],[np.nanmean(Sz_freqs)-ss.sem(Sz_freqs,nan_policy='omit'),np.nanmean(Sz_freqs)+ss.sem(Sz_freqs,nan_policy='omit')],'k-')
    
    offset += 1
   
    x_jitter1 = pd.Series(np.random.normal(loc=0, scale=jitter, size=Strt_freqs.shape))+offset
    ax.plot(x_jitter1, Strt_freqs, 'o', alpha=.40, zorder=1, ms=8, mew=1, color='b')
    ax.plot([offset-0.2,offset+0.2],[np.nanmean(Strt_freqs),np.nanmean(Strt_freqs)],'k-')
    ax.plot([offset-0.1,offset+0.1],[np.nanmean(Strt_freqs)+ss.sem(Strt_freqs,nan_policy='omit'),np.nanmean(Strt_freqs)+ss.sem(Strt_freqs,nan_policy='omit')],'k-')
    ax.plot([offset-0.1,offset+0.1],[np.nanmean(Strt_freqs)-ss.sem(Strt_freqs,nan_policy='omit'),np.nanmean(Strt_freqs)-ss.sem(Strt_freqs,nan_policy='omit')],'k-')
    ax.plot([offset,offset],[np.nanmean(Strt_freqs)-ss.sem(Strt_freqs,nan_policy='omit'),np.nanmean(Strt_freqs)+ss.sem(Strt_freqs,nan_policy='omit')],'k-')

    ax.set_xticklabels(['Full Seizure','First Second'])
    fig.suptitle(location + ' Oscillation Frequency')
    
    w,pf = ss.ttest_rel(np.squeeze(Sz_freqs),np.squeeze(Strt_freqs),nan_policy='omit')
    w,pc = ss.ttest_rel(np.squeeze(Sz_cycs),np.squeeze(Strt_cycs),nan_policy='omit')
    
    
    print(location + ' First Second Frequency = ' + 
        str(np.around(np.nanmean(Strt_freqs),decimals=3)) + ', SEM = ' +
        str(np.around(ss.sem(Strt_freqs,nan_policy='omit'),decimals=2)))
    print(location + ' Full Seizure Frequency = ' +
          str(np.around(np.nanmean(Sz_freqs),decimals=3)) + ', SEM = ' +
          str(np.around(ss.sem(Sz_freqs,nan_policy='omit'),decimals=2)))
    print(location + ' First Second Cycle Firing = ' +
          str(np.around(np.nanmean(Strt_cycs),decimals=2))+ ', SEM = ' +
          str(np.around(ss.sem(Strt_cycs,nan_policy='omit'),decimals=2)))
    print(location + ' Full Seizure Cycle Firing = ' +
          str(np.around(np.nanmean(Sz_cycs),decimals=2))+ ', SEM = ' +
          str(np.around(ss.sem(Sz_cycs,nan_policy='omit'),decimals=2)))
    print(location + ' test of frequency = ' +
          str(np.around(pf,decimals=100)))
    print(location + ' test of cycle firing = ' +
          str(np.around(pc,decimals=50)))
    
    
    
